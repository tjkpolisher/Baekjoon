# 2082: 시계
# 특이사항: 다국어(영어)(한국어 번역)
# 출처: Croatian Highschool Competitions in Informatics 2001 Regional Competition - Juniors 3번
# 알고리즘 분류: 구현/브루트포스 알고리즘

# 1. 5개의 줄에 걸쳐 디지털 시계의 숫자를 나타내는 문자열 출력
# 2. 입력받은 문자들을 각각 4개의 개별적인 숫자를 나타내는 이중 리스트로 구성
# 3. 각 숫자를 0에서 9까지의 숫자를 나타내는 디지털 문자와 비교하고, 가장 차이가 적은 숫자를 체크
# 3-1. 가장 차이가 적은 숫자가 여러 개일 경우 가장 앞서는 숫자로 체크
# 4. 각 숫자를 정수로 변환 후 주어진 양식을 따라 시각 출력

import sys
input = sys.stdin.readline

clock = [
    [["#", "#", "#"], ["#", ".", "#"], ["#", ".", "#"], ["#", ".", "#"], ["#", "#", "#"]],  # 0
    [[".", ".", "#"], [".", ".", "#"], [".", ".", "#"], [".", ".", "#"], [".", ".", "#"]],  # 1
    [["#", "#", "#"], [".", ".", "#"], ["#", "#", "#"], ["#", ".", "."], ["#", "#", "#"]],  # 2
    [["#", "#", "#"], [".", ".", "#"], ["#", "#", "#"], [".", ".", "#"], ["#", "#", "#"]],  # 3
    [["#", ".", "#"], ["#", ".", "#"], ["#", "#", "#"], [".", ".", "#"], [".", ".", "#"]],  # 4
    [["#", "#", "#"], ["#", ".", "."], ["#", "#", "#"], [".", ".", "#"], ["#", "#", "#"]],  # 5
    [["#", "#", "#"], ["#", ".", "."], ["#", "#", "#"], ["#", ".", "#"], ["#", "#", "#"]],  # 6
    [["#", "#", "#"], [".", ".", "#"], [".", ".", "#"], [".", ".", "#"], [".", ".", "#"]],  # 7
    [["#", "#", "#"], ["#", ".", "#"], ["#", "#", "#"], ["#", ".", "#"], ["#", "#", "#"]],  # 8
    [["#", "#", "#"], ["#", ".", "#"], ["#", "#", "#"], [".", ".", "#"], [".", ".", "#"]],  # 9
]
clock_table = {i: clock[i] for i in range(10)}

n1, n2, n3, n4 = [], [], [], []
for _ in range(5):
    n1_, n2_, n3_, n4_ = input().rstrip().split()
    n1.append(list(n1_))
    n2.append(list(n2_))
    n3.append(list(n3_))
    n4.append(list(n4_))

times = []
for i, n in enumerate([n1, n2, n3, n4]):
    if i == 0:
        clock_list = clock[:3]
    elif i == 2:
        clock_list = clock[:6]
    else:
        clock_list = clock

    counters = []
    for j, c in enumerate(clock_list):
        cnt = 0
        # 5행 3열을 순회하면서 다른 문자 체크
        for row in range(5):
            for col in range(3):
                if n[row][col] == '#' and c[row][col] == '.':
                    cnt += 1
        if cnt == 0:
            times.append(j)
            break
        else:
            counters.append(cnt)
    else:
        min_cnt = min(counters)
        times.append(counters.index(min_cnt))

print(f"{times[0]}{times[1]}:{times[2]}{times[3]}")
